use program::posix::ast;

grammar;

pub Program: ast::Program = {
    // TODO: We need our own lexer to make this rule work.
    // <p: Program> "\n"+ <c: Commands> => {
    //     let (mut p, c) = (p, c);
    //     p.0.push(box c);
    //     p
    // },
    Compound<Job> => <>,
    Job => ast::Program(vec![box <>]),
}

Compound<Lower>: ast::Program = {
    <p: Compound<Lower>> ";" <j: Lower> => {
        let (mut p, j) = (p, j);
        p.0.push(box j);
        p
    },
    <p: Compound<Lower>> ";" => p,
    <p: Lower> ";" => ast::Program(vec![box p]),
}

Job: ast::Command = {
    <j: Job> "&" <cs: Commands> => {
        let bg = ast::Command::Background(box j);
        ast::Command::Pair(box bg, box cs)
    },
    <j: Job> "&" => ast::Command::Background(box j),
    Commands => <>,
}

CommandCompound: ast::Program = Compound<Job>;

Commands: ast::Command = {
    "(" <p: Program> ")" => {
        ast::Command::Subshell(box p)
    },
    "{" <p: CommandCompound> "}" => {
        ast::Command::Compound(box p)
    },
    // BridgedProgram => <>,
    <cs: Commands> "&&" <p: Pipeline> => {
        ast::Command::And(box cs, box p)
    },
    <cs: Commands> "||" <p: Pipeline> => {
        ast::Command::Or(box cs, box p)
    },
    Pipeline => <>,
}

Pipeline: ast::Command = {
    "!" <ps: PipelineSeq> => ast::Command::Not(box ps),
    <ps: PipelineSeq> => ps,
}

PipelineSeq: ast::Command = {
    <ps: PipelineSeq> "|" "\n"* <c: Command> => {
        ast::Command::Pipeline(box ps, box c)
    },
    <c: Command> => c,
}

pub Command: ast::Command = Word+ => ast::Command::Simple(<>);

pub Word: ast::Word = r"[a-zA-Z0-9-_]+" => ast::Word(<>.into());
